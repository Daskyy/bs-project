

type Query {
     # Beispiel: Liste von Events auslesen
     events(criteria: EventCriteriaInput, page: PaginationInput): [EventGQL!]!
     # Beispiel: Einzelnen User auslesen
     user(id: ID!): UserGQL
     # Beispiel: Einzelnes Event auslesen
     event(id: ID!): EventGQL

  # Address
    # Beispiel: Liste von Addressen auslesen
     addresses(criteria: AddressCriteriaInput, page: PaginationInput): [AddressGQL!]!
    # Beispiel: Einzelne Address auslesen
     address(id: ID!): AddressGQL

  # EventLocation
    # Beispiel: Liste von EventLocations auslesen
     eventLocations(criteria: EventLocationCriteriaInput): [EventLocationGQL!]!
    # Beispiel: Einzelne EventLocation auslesen
     eventLocation(id: ID!): EventLocationGQL

}

# Mutations
type Mutation {


  purchaseTicket(userId: ID!, eventId: ID!, ticketamount: Int!,paymentmethodId: String!, voucher:String): TicketGQL!

  refundTicket(ticketId: ID!): PaymentGQL!

  #Address
  # Beispiel: Address anlegen
  createAddress(input: AddressInput): AddressGQL!
  # Beispiel: Address löschen
  deleteAddress(id: ID!): AddressGQL!
    # Beispiel: Address aktualisieren
  updateAddress(id:ID!, input: AddressInput): AddressGQL!
  #Userf
  # Beispiel: User anlegen
  createUser(input: UserInput): UserGQL!
  # Beispiel: User löschen
  deleteUser(id: ID!): UserGQL!
  # Beispiel: User aktualisieren
  updateUser(id: ID!, input: UserInput): UserGQL!

  #Event
  # Beispiel: Event anlegen
  createEvent(input: EventInput): EventGQL!
  # Beispiel: Event löschen
  deleteEvent(id: ID!): EventGQL!
  # Beispiel: Event aktualisieren
  updateEvent(id: ID!, input: EventInput): EventGQL!
  # Blocks a user
  blockUser(eventId: ID!, userId: ID!): EventGQL!
}

# Models
type TicketGQL{
  id: ID!
  event: EventGQL!
  user: UserGQL!
  payment: PaymentGQL!
}

type AddressGQL{
  id: ID!
  street: String!
  no: Int!
  city: String!
  zipCode: Int!
  country: String!
}

type EventGQL {
  id: ID!
  name: String!
  description: String
  startDate: String!
  endDate: String!
  ticketCount: Int!   #todo ticketcount und sold in event in domain anpassen
  ticketsSold: Int!  #todo
  maxTicketsPerUser: Int!
  artists: [UserGQL!]!
  location: EventLocationGQL
  blockList: [UserGQL!]  #
  ticketPrice: Int!
  # usw.
}

type EventLocationGQL {
  id: ID!
  address: AddressGQL!
  name: String!
  capacity: Int!
}
#EventCriteria als type nicht notwendig, da es nur für die Query-Methode verwendet wird

type PaymentGQL{
    id: ID!
    paymentMethodId: ID!
    amount: Int!
    status: StatusGQL!
    paymentIntentId: String!
}

enum StatusGQL{
  OPEN
  COMPLETED
  FAILED
  CANCELLED
  REFUNDED
}

enum PermissionGQL{
  STAFF
  ARTIST
  CUSTOMER
}



type UserGQL {
  id: ID!
  name: String!
  email: String!
  password: String!
  permission: PermissionGQL!
}


# Input-Types
input UserInput {
  name: String
  email: String
  password: String
  permission: PermissionGQL
  id: ID
}

input AddressCriteriaInput {
    # z.B. Filterkriterien
    street: String
    city: String
    zipCode: Int
    country: String
}

input EventLocationCriteriaInput {
  # z.B. Filterkriterien
  addressentity_id: String
  name: String
  capacity: Int
}

input EventInput {
  name: String
  description: String
  startDate: String
  endDate: String
  ticketCount: Int
  ticketsSold: Int
  maxTicketsPerUser: Int
  artists: [ID!]!
  location: ID
  blockList: [ID!]!
  ticketPrice: Int
}

input EventLocationInput {
  id:ID
  address: AddressInput!
  name: String!
  capacity: Int!
}

input PaginationInput {
  page: Int
  pageSize: Int
}

input AddressInput{
  id:ID
  street: String
  no: Int
  city: String
  zipCode: Int
  country: String
}

input EventCriteriaInput {
  # z.B. Filterkriterien
  description: String
  name: String
  location_id: String
  maxticketsperuser: Int
  ticketprice: Int
  ticketcount: Int
  ticketssold: Int
  artists_id: String
  blockList_id: String
}